import axios, { AxiosInstance } from "axios";
import { logger } from "../utils/logger";
import { config } from "../config";
import * as fs from "fs/promises";
import * as path from "path";

export interface GitLabCommitAction {
  action: "create" | "update" | "delete";
  file_path: string;
  content?: string;
}

export interface GitLabPushResult {
  success: boolean;
  commitId?: string;
  webUrl?: string;
  error?: string;
}

export class GitLabService {
  private client: AxiosInstance;

  constructor() {
    this.client = axios.create({
      baseURL: config.gitlab.url,
      headers: {
        "PRIVATE-TOKEN": config.gitlab.token,
      },
    });
  }

  /**
   * Push files from workspace to GitLab repository
   */
  async pushWorkspaceToRepo(
    threadId: string,
    projectId: string,
    branch: string = config.gitlab.defaultBranch,
    commitMessage?: string
  ): Promise<GitLabPushResult> {
    try {
      logger.info("Pushing workspace to GitLab", {
        threadId,
        projectId,
        branch,
      });

      // Get all files from workspace
      const workspacePath = path.join(config.docker.workspaceVolume, threadId);
      const files = await this.getWorkspaceFiles(workspacePath);

      if (files.length === 0) {
        return {
          success: false,
          error: "No files found in workspace",
        };
      }

      // Create commit actions with services/{threadId}/ prefix
      const actions: GitLabCommitAction[] = files.map((file) => ({
        action: "create",
        file_path: `services/${threadId}/${file.path}`,
        content: file.content,
      }));

      // Create commit
      const message =
        commitMessage ||
        `Add generated files from Claude Code (Thread: ${threadId})`;

      const response = await this.client.post(
        `/api/v4/projects/${projectId}/repository/commits`,
        {
          branch,
          commit_message: message,
          actions,
        }
      );

      logger.info("Successfully pushed to GitLab", {
        threadId,
        commitId: response.data.id,
      });

      return {
        success: true,
        commitId: response.data.id,
        webUrl: response.data.web_url,
      };
    } catch (error) {
      logger.error("Failed to push to GitLab", { error, threadId, projectId });
      return {
        success: false,
        error: error instanceof Error ? error.message : "Unknown error",
      };
    }
  }

  /**
   * Create a new branch in GitLab repository
   */
  async createBranch(
    projectId: string,
    branchName: string,
    ref: string = config.gitlab.defaultBranch
  ): Promise<{ success: boolean; error?: string }> {
    try {
      await this.client.post(
        `/api/v4/projects/${projectId}/repository/branches`,
        {
          branch: branchName,
          ref,
        }
      );

      logger.info("Branch created", { projectId, branchName });
      return { success: true };
    } catch (error) {
      logger.error("Failed to create branch", { error, projectId, branchName });
      return {
        success: false,
        error: error instanceof Error ? error.message : "Unknown error",
      };
    }
  }

  /**
   * Create a merge request
   */
  async createMergeRequest(
    projectId: string,
    sourceBranch: string,
    targetBranch: string = config.gitlab.defaultBranch,
    title?: string,
    description?: string
  ): Promise<{ success: boolean; webUrl?: string; error?: string }> {
    try {
      const response = await this.client.post(
        `/api/v4/projects/${projectId}/merge_requests`,
        {
          source_branch: sourceBranch,
          target_branch: targetBranch,
          title: title || `Merge ${sourceBranch} into ${targetBranch}`,
          description: description || "Generated by Claude Code",
        }
      );

      logger.info("Merge request created", {
        projectId,
        mrId: response.data.iid,
      });

      return {
        success: true,
        webUrl: response.data.web_url,
      };
    } catch (error) {
      logger.error("Failed to create merge request", {
        error,
        projectId,
        sourceBranch,
      });
      return {
        success: false,
        error: error instanceof Error ? error.message : "Unknown error",
      };
    }
  }

  /**
   * Get all files from workspace directory
   */
  private async getWorkspaceFiles(
    dir: string,
    baseDir: string = ""
  ): Promise<Array<{ path: string; content: string }>> {
    const files: Array<{ path: string; content: string }> = [];

    try {
      const entries = await fs.readdir(dir, { withFileTypes: true });

      for (const entry of entries) {
        const fullPath = path.join(dir, entry.name);
        const relativePath = path.join(baseDir, entry.name);

        // Skip hidden files and directories
        if (entry.name.startsWith(".")) {
          continue;
        }

        if (entry.isDirectory()) {
          const subFiles = await this.getWorkspaceFiles(fullPath, relativePath);
          files.push(...subFiles);
        } else {
          const content = await fs.readFile(fullPath, "utf-8");
          files.push({ path: relativePath, content });
        }
      }
    } catch (error) {
      logger.error("Failed to read workspace files", { error, dir });
    }

    return files;
  }

  /**
   * Check if GitLab token is valid
   */
  async validateToken(): Promise<boolean> {
    try {
      await this.client.get("/api/v4/user");
      return true;
    } catch (error) {
      logger.error("GitLab token validation failed", { error });
      return false;
    }
  }

  /**
   * Get project information
   */
  async getProject(projectId: string): Promise<any> {
    try {
      const response = await this.client.get(
        `/api/v4/projects/${projectId}`
      );
      return response.data;
    } catch (error) {
      logger.error("Failed to get project info", { error, projectId });
      throw error;
    }
  }
}
